<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="generator" content="rustdoc"><meta name="description" content="A WebAssembly linear memory."><title>Memory in wasmtime - Rust</title><link rel="preload" as="font" type="font/woff2" crossorigin href="../static.files/SourceSerif4-Regular-46f98efaafac5295.ttf.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../static.files/FiraSans-Regular-018c141bf0843ffd.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../static.files/FiraSans-Medium-8f9a781e4970d388.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../static.files/SourceCodePro-Regular-562dcc5011b6de7d.ttf.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../static.files/SourceCodePro-Semibold-d899c5a5c4aeb14a.ttf.woff2"><link rel="stylesheet" href="../static.files/normalize-76eba96aa4d2e634.css"><link rel="stylesheet" href="../static.files/rustdoc-804b98a1284a310a.css"><meta name="rustdoc-vars" data-root-path="../" data-static-root-path="../static.files/" data-current-crate="wasmtime" data-themes="" data-resource-suffix="" data-rustdoc-version="1.76.0-nightly (5ac4c8a63 2023-12-20)" data-channel="nightly" data-search-js="search-2b6ce74ff89ae146.js" data-settings-js="settings-4313503d2e1961c2.js" ><script src="../static.files/storage-f2adc0d6ca4d09fb.js"></script><script defer src="sidebar-items.js"></script><script defer src="../static.files/main-305769736d49e732.js"></script><noscript><link rel="stylesheet" href="../static.files/noscript-feafe1bb7466e4bd.css"></noscript><link rel="alternate icon" type="image/png" href="../static.files/favicon-16x16-8b506e7a72182f1c.png"><link rel="alternate icon" type="image/png" href="../static.files/favicon-32x32-422f7d1d52889060.png"><link rel="icon" type="image/svg+xml" href="../static.files/favicon-2c020d218678b618.svg"></head><body class="rustdoc struct"><!--[if lte IE 11]><div class="warning">This old browser is unsupported and will most likely display funky things.</div><![endif]--><nav class="mobile-topbar"><button class="sidebar-menu-toggle">&#9776;</button></nav><nav class="sidebar"><div class="sidebar-crate"><h2><a href="../wasmtime/index.html">wasmtime</a><span class="version">8.0.1</span></h2></div><h2 class="location"><a href="#">Memory</a></h2><div class="sidebar-elems"><section><h3><a href="#implementations">Methods</a></h3><ul class="block method"><li><a href="#method.data">data</a></li><li><a href="#method.data_and_store_mut">data_and_store_mut</a></li><li><a href="#method.data_mut">data_mut</a></li><li><a href="#method.data_ptr">data_ptr</a></li><li><a href="#method.data_size">data_size</a></li><li><a href="#method.grow">grow</a></li><li><a href="#method.new">new</a></li><li><a href="#method.read">read</a></li><li><a href="#method.size">size</a></li><li><a href="#method.ty">ty</a></li><li><a href="#method.write">write</a></li></ul><h3><a href="#trait-implementations">Trait Implementations</a></h3><ul class="block trait-implementation"><li><a href="#impl-Clone-for-Memory">Clone</a></li><li><a href="#impl-Copy-for-Memory">Copy</a></li><li><a href="#impl-Debug-for-Memory">Debug</a></li><li><a href="#impl-From%3CMemory%3E-for-Extern">From&lt;Memory&gt;</a></li></ul><h3><a href="#synthetic-implementations">Auto Trait Implementations</a></h3><ul class="block synthetic-implementation"><li><a href="#impl-RefUnwindSafe-for-Memory">RefUnwindSafe</a></li><li><a href="#impl-Send-for-Memory">Send</a></li><li><a href="#impl-Sync-for-Memory">Sync</a></li><li><a href="#impl-Unpin-for-Memory">Unpin</a></li><li><a href="#impl-UnwindSafe-for-Memory">UnwindSafe</a></li></ul><h3><a href="#blanket-implementations">Blanket Implementations</a></h3><ul class="block blanket-implementation"><li><a href="#impl-Any-for-T">Any</a></li><li><a href="#impl-Borrow%3CT%3E-for-T">Borrow&lt;T&gt;</a></li><li><a href="#impl-BorrowMut%3CT%3E-for-T">BorrowMut&lt;T&gt;</a></li><li><a href="#impl-From%3CT%3E-for-T">From&lt;T&gt;</a></li><li><a href="#impl-Into%3CU%3E-for-T">Into&lt;U&gt;</a></li><li><a href="#impl-ToOwned-for-T">ToOwned</a></li><li><a href="#impl-TryFrom%3CU%3E-for-T">TryFrom&lt;U&gt;</a></li><li><a href="#impl-TryInto%3CU%3E-for-T">TryInto&lt;U&gt;</a></li></ul></section><h2><a href="index.html">In crate wasmtime</a></h2></div></nav><div class="sidebar-resizer"></div>
    <main><div class="width-limiter"><nav class="sub"><form class="search-form"><span></span><div id="sidebar-button" tabindex="-1"><a href="../wasmtime/all.html" title="show sidebar"></a></div><input class="search-input" name="search" aria-label="Run search in the documentation" autocomplete="off" spellcheck="false" placeholder="Click or press ‘S’ to search, ‘?’ for more options…" type="search"><div id="help-button" tabindex="-1"><a href="../help.html" title="help">?</a></div><div id="settings-menu" tabindex="-1"><a href="../settings.html" title="settings"><img width="22" height="22" alt="Change settings" src="../static.files/wheel-7b819b6101059cd0.svg"></a></div></form></nav><section id="main-content" class="content"><div class="main-heading"><h1>Struct <a href="index.html">wasmtime</a>::<wbr><a class="struct" href="#">Memory</a><button id="copy-path" title="Copy item path to clipboard"><img src="../static.files/clipboard-7571035ce49a181d.svg" width="19" height="18" alt="Copy item path"></button></h1><span class="out-of-band"><a class="src" href="../src/wasmtime/memory.rs.html#205">source</a> · <button id="toggle-all-docs" title="collapse all docs">[<span>&#x2212;</span>]</button></span></div><pre class="rust item-decl"><code>pub struct Memory(<span class="comment">/* private fields */</span>);</code></pre><details class="toggle top-doc" open><summary class="hideme"><span>Expand description</span></summary><div class="docblock"><p>A WebAssembly linear memory.</p>
<p>WebAssembly memories represent a contiguous array of bytes that have a size
that is always a multiple of the WebAssembly page size, currently 64
kilobytes.</p>
<p>WebAssembly memory is used for global data (not to be confused with wasm
<code>global</code> items), statics in C/C++/Rust, shadow stack memory, etc. Accessing
wasm memory is generally quite fast.</p>
<p>Memories, like other wasm items, are owned by a <a href="struct.Store.html" title="struct wasmtime::Store"><code>Store</code></a>.</p>
<h2 id="memory-and-safety"><a href="#memory-and-safety"><code>Memory</code> and Safety</a></h2>
<p>Linear memory is a lynchpin of safety for WebAssembly. In Wasmtime there are
safe methods of interacting with a <a href="struct.Memory.html" title="struct wasmtime::Memory"><code>Memory</code></a>:</p>
<ul>
<li><a href="struct.Memory.html#method.read" title="method wasmtime::Memory::read"><code>Memory::read</code></a></li>
<li><a href="struct.Memory.html#method.write" title="method wasmtime::Memory::write"><code>Memory::write</code></a></li>
<li><a href="struct.Memory.html#method.data" title="method wasmtime::Memory::data"><code>Memory::data</code></a></li>
<li><a href="struct.Memory.html#method.data_mut" title="method wasmtime::Memory::data_mut"><code>Memory::data_mut</code></a></li>
</ul>
<p>Note that all of these consider the entire store context as borrowed for the
duration of the call or the duration of the returned slice. This largely
means that while the function is running you’ll be unable to borrow anything
else from the store. This includes getting access to the <code>T</code> on
<a href="struct.Store.html" title="struct wasmtime::Store"><code>Store&lt;T&gt;</code></a>, but it also means that you can’t recursively
call into WebAssembly for instance.</p>
<p>If you’d like to dip your toes into handling <a href="struct.Memory.html" title="struct wasmtime::Memory"><code>Memory</code></a> in a more raw
fashion (e.g. by using raw pointers or raw slices), then there’s a few
important points to consider when doing so:</p>
<ul>
<li>
<p>Any recursive calls into WebAssembly can possibly modify any byte of the
entire memory. This means that whenever wasm is called Rust can’t have any
long-lived borrows live across the wasm function call. Slices like <code>&amp;mut [u8]</code> will be violated because they’re not actually exclusive at that
point, and slices like <code>&amp;[u8]</code> are also violated because their contents
may be mutated.</p>
</li>
<li>
<p>WebAssembly memories can grow, and growth may change the base pointer.
This means that even holding a raw pointer to memory over a wasm function
call is also incorrect. Anywhere in the function call the base address of
memory may change. Note that growth can also be requested from the
embedding API as well.</p>
</li>
</ul>
<p>As a general rule of thumb it’s recommended to stick to the safe methods of
<a href="struct.Memory.html" title="struct wasmtime::Memory"><code>Memory</code></a> if you can. It’s not advised to use raw pointers or <code>unsafe</code>
operations because of how easy it is to accidentally get things wrong.</p>
<p>Some examples of safely interacting with memory are:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>wasmtime::{Memory, Store, MemoryAccessError};

<span class="comment">// Memory can be read and written safely with the `Memory::read` and
// `Memory::write` methods.
// An error is returned if the copy did not succeed.
</span><span class="kw">fn </span>safe_examples(mem: Memory, store: <span class="kw-2">&amp;mut </span>Store&lt;()&gt;) -&gt; <span class="prelude-ty">Result</span>&lt;(), MemoryAccessError&gt; {
    <span class="kw">let </span>offset = <span class="number">5</span>;
    mem.write(<span class="kw-2">&amp;mut *</span>store, offset, <span class="string">b"hello"</span>)<span class="question-mark">?</span>;
    <span class="kw">let </span><span class="kw-2">mut </span>buffer = [<span class="number">0u8</span>; <span class="number">5</span>];
    mem.read(<span class="kw-2">&amp;</span>store, offset, <span class="kw-2">&amp;mut </span>buffer)<span class="question-mark">?</span>;
    <span class="macro">assert_eq!</span>(<span class="string">b"hello"</span>, <span class="kw-2">&amp;</span>buffer);

    <span class="comment">// Note that while this is safe care must be taken because the indexing
    // here may panic if the memory isn't large enough.
    </span><span class="macro">assert_eq!</span>(<span class="kw-2">&amp;</span>mem.data(<span class="kw-2">&amp;</span>store)[offset..offset + <span class="number">5</span>], <span class="string">b"hello"</span>);
    mem.data_mut(<span class="kw-2">&amp;mut *</span>store)[offset..offset + <span class="number">5</span>].copy_from_slice(<span class="string">b"bye!!"</span>);

    <span class="prelude-val">Ok</span>(())
}</code></pre></div>
<p>It’s worth also, however, covering some examples of <strong>incorrect</strong>,
<strong>unsafe</strong> usages of <code>Memory</code>. Do not do these things!</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>wasmtime::{Memory, Store};

<span class="comment">// NOTE: All code in this function is not safe to execute and may cause
// segfaults/undefined behavior at runtime. Do not copy/paste these examples
// into production code!
</span><span class="kw">unsafe fn </span>unsafe_examples(mem: Memory, store: <span class="kw-2">&amp;mut </span>Store&lt;()&gt;) -&gt; <span class="prelude-ty">Result</span>&lt;()&gt; {
    <span class="comment">// First and foremost, any borrow can be invalidated at any time via the
    // `Memory::grow` function. This can relocate memory which causes any
    // previous pointer to be possibly invalid now.
    </span><span class="kw">let </span>pointer: <span class="kw-2">&amp;</span>u8 = <span class="kw-2">&amp;*</span>mem.data_ptr(<span class="kw-2">&amp;</span>store);
    mem.grow(<span class="kw-2">&amp;mut *</span>store, <span class="number">1</span>)<span class="question-mark">?</span>; <span class="comment">// invalidates `pointer`!
    // println!("{}", *pointer); // FATAL: use-after-free

    // Note that the use-after-free also applies to slices, whether they're
    // slices of bytes or strings.
    </span><span class="kw">let </span>mem_slice = std::slice::from_raw_parts(
        mem.data_ptr(<span class="kw-2">&amp;</span>store),
        mem.data_size(<span class="kw-2">&amp;</span>store),
    );
    <span class="kw">let </span>slice: <span class="kw-2">&amp;</span>[u8] = <span class="kw-2">&amp;</span>mem_slice[<span class="number">0x100</span>..<span class="number">0x102</span>];
    mem.grow(<span class="kw-2">&amp;mut *</span>store, <span class="number">1</span>)<span class="question-mark">?</span>; <span class="comment">// invalidates `slice`!
    // println!("{:?}", slice); // FATAL: use-after-free

    // The `Memory` type may be stored in other locations, so if you hand
    // off access to the `Store` then those locations may also call
    // `Memory::grow` or similar, so it's not enough to just audit code for
    // calls to `Memory::grow`.
    </span><span class="kw">let </span>pointer: <span class="kw-2">&amp;</span>u8 = <span class="kw-2">&amp;*</span>mem.data_ptr(<span class="kw-2">&amp;</span>store);
    some_other_function(store); <span class="comment">// may invalidate `pointer` through use of `store`
    // println!("{:?}", pointer); // FATAL: maybe a use-after-free

    // An especially subtle aspect of accessing a wasm instance's memory is
    // that you need to be extremely careful about aliasing. Anyone at any
    // time can call `data_unchecked()` or `data_unchecked_mut()`, which
    // means you can easily have aliasing mutable references:
    </span><span class="kw">let </span>ref1: <span class="kw-2">&amp;</span>u8 = <span class="kw-2">&amp;*</span>mem.data_ptr(<span class="kw-2">&amp;</span>store).add(<span class="number">0x100</span>);
    <span class="kw">let </span>ref2: <span class="kw-2">&amp;mut </span>u8 = <span class="kw-2">&amp;mut *</span>mem.data_ptr(<span class="kw-2">&amp;</span>store).add(<span class="number">0x100</span>);
    <span class="comment">// *ref2 = *ref1; // FATAL: violates Rust's aliasing rules

    </span><span class="prelude-val">Ok</span>(())
}</code></pre></div>
<p>Overall there’s some general rules of thumb when unsafely working with
<code>Memory</code> and getting raw pointers inside of it:</p>
<ul>
<li>If you never have a “long lived” pointer into memory, you’re likely in the
clear. Care still needs to be taken in threaded scenarios or when/where
data is read, but you’ll be shielded from many classes of issues.</li>
<li>Long-lived pointers must always respect Rust’a aliasing rules. It’s ok for
shared borrows to overlap with each other, but mutable borrows must
overlap with nothing.</li>
<li>Long-lived pointers are only valid if they’re not invalidated for their
lifetime. This means that <a href="struct.Store.html" title="struct wasmtime::Store"><code>Store</code></a> isn’t used to reenter
wasm or the memory itself is never grown or otherwise modified/aliased.</li>
</ul>
<p>At this point it’s worth reiterating again that unsafely working with
<code>Memory</code> is pretty tricky and not recommended! It’s highly recommended to
use the safe methods to interact with <a href="struct.Memory.html" title="struct wasmtime::Memory"><code>Memory</code></a> whenever possible.</p>
<h3 id="memory-safety-and-threads"><a href="#memory-safety-and-threads"><code>Memory</code> Safety and Threads</a></h3>
<p>Currently the <code>wasmtime</code> crate does not implement the wasm threads proposal,
but it is planned to do so. It may be interesting to readers to see how this
affects memory safety and what was previously just discussed as well.</p>
<p>Once threads are added into the mix, all of the above rules still apply.
There’s an additional consideration that all reads and writes can happen
concurrently, though. This effectively means that any borrow into wasm
memory are virtually never safe to have.</p>
<p>Mutable pointers are fundamentally unsafe to have in a concurrent scenario
in the face of arbitrary wasm code. Only if you dynamically know for sure
that wasm won’t access a region would it be safe to construct a mutable
pointer. Additionally even shared pointers are largely unsafe because their
underlying contents may change, so unless <code>UnsafeCell</code> in one form or
another is used everywhere there’s no safety.</p>
<p>One important point about concurrency is that while <a href="struct.Memory.html#method.grow" title="method wasmtime::Memory::grow"><code>Memory::grow</code></a> can
happen concurrently it will never relocate the base pointer. Shared
memories must always have a maximum size and they will be preallocated such
that growth will never relocate the base pointer. The current size of the
memory may still change over time though.</p>
<p>Overall the general rule of thumb for shared memories is that you must
atomically read and write everything. Nothing can be borrowed and everything
must be eagerly copied out. This means that <a href="struct.Memory.html#method.data" title="method wasmtime::Memory::data"><code>Memory::data</code></a> and
<a href="struct.Memory.html#method.data_mut" title="method wasmtime::Memory::data_mut"><code>Memory::data_mut</code></a> won’t work in the future (they’ll probably return an
error) for shared memories when they’re implemented. When possible it’s
recommended to use <a href="struct.Memory.html#method.read" title="method wasmtime::Memory::read"><code>Memory::read</code></a> and <a href="struct.Memory.html#method.write" title="method wasmtime::Memory::write"><code>Memory::write</code></a> which will still
be provided.</p>
</div></details><h2 id="implementations" class="section-header">Implementations<a href="#implementations" class="anchor">§</a></h2><div id="implementations-list"><details class="toggle implementors-toggle" open><summary><section id="impl-Memory" class="impl"><a class="src rightside" href="../src/wasmtime/memory.rs.html#207-579">source</a><a href="#impl-Memory" class="anchor">§</a><h3 class="code-header">impl <a class="struct" href="struct.Memory.html" title="struct wasmtime::Memory">Memory</a></h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.new" class="method"><a class="src rightside" href="../src/wasmtime/memory.rs.html#237-239">source</a><h4 class="code-header">pub fn <a href="#method.new" class="fn">new</a>(store: impl <a class="trait" href="trait.AsContextMut.html" title="trait wasmtime::AsContextMut">AsContextMut</a>, ty: <a class="struct" href="struct.MemoryType.html" title="struct wasmtime::MemoryType">MemoryType</a>) -&gt; <a class="type" href="type.Result.html" title="type wasmtime::Result">Result</a>&lt;<a class="struct" href="struct.Memory.html" title="struct wasmtime::Memory">Memory</a>&gt;</h4></section></summary><div class="docblock"><p>Creates a new WebAssembly memory given the configuration of <code>ty</code>.</p>
<p>The <code>store</code> argument will be the owner of the returned <a href="struct.Memory.html" title="struct wasmtime::Memory"><code>Memory</code></a>. All
WebAssembly memory is initialized to zero.</p>
<h5 id="panics"><a href="#panics">Panics</a></h5>
<p>This function will panic if the <a href="struct.Store.html" title="struct wasmtime::Store"><code>Store</code></a> has a
<a href="%60crate::ResourceLimiterAsync%60"><code>ResourceLimiterAsync</code></a> (see also:
<a href="%60crate::Store::limiter_async%60"><code>Store::limiter_async</code></a>). When
using an async resource limiter, use [<code>Memory::new_async</code>] instead.</p>
<h5 id="examples"><a href="#examples">Examples</a></h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let </span>engine = Engine::default();
<span class="kw">let </span><span class="kw-2">mut </span>store = Store::new(<span class="kw-2">&amp;</span>engine, ());

<span class="kw">let </span>memory_ty = MemoryType::new(<span class="number">1</span>, <span class="prelude-val">None</span>);
<span class="kw">let </span>memory = Memory::new(<span class="kw-2">&amp;mut </span>store, memory_ty)<span class="question-mark">?</span>;

<span class="kw">let </span>module = Module::new(<span class="kw-2">&amp;</span>engine, <span class="string">"(module (memory (import \"\" \"\") 1))"</span>)<span class="question-mark">?</span>;
<span class="kw">let </span>instance = Instance::new(<span class="kw-2">&amp;mut </span>store, <span class="kw-2">&amp;</span>module, <span class="kw-2">&amp;</span>[memory.into()])<span class="question-mark">?</span>;
<span class="comment">// ...</span></code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.ty" class="method"><a class="src rightside" href="../src/wasmtime/memory.rs.html#295-299">source</a><h4 class="code-header">pub fn <a href="#method.ty" class="fn">ty</a>(&amp;self, store: impl <a class="trait" href="trait.AsContext.html" title="trait wasmtime::AsContext">AsContext</a>) -&gt; <a class="struct" href="struct.MemoryType.html" title="struct wasmtime::MemoryType">MemoryType</a></h4></section></summary><div class="docblock"><p>Returns the underlying type of this memory.</p>
<h5 id="panics-1"><a href="#panics-1">Panics</a></h5>
<p>Panics if this memory doesn’t belong to <code>store</code>.</p>
<h5 id="examples-1"><a href="#examples-1">Examples</a></h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let </span>engine = Engine::default();
<span class="kw">let </span><span class="kw-2">mut </span>store = Store::new(<span class="kw-2">&amp;</span>engine, ());
<span class="kw">let </span>module = Module::new(<span class="kw-2">&amp;</span>engine, <span class="string">"(module (memory (export \"mem\") 1))"</span>)<span class="question-mark">?</span>;
<span class="kw">let </span>instance = Instance::new(<span class="kw-2">&amp;mut </span>store, <span class="kw-2">&amp;</span>module, <span class="kw-2">&amp;</span>[])<span class="question-mark">?</span>;
<span class="kw">let </span>memory = instance.get_memory(<span class="kw-2">&amp;mut </span>store, <span class="string">"mem"</span>).unwrap();
<span class="kw">let </span>ty = memory.ty(<span class="kw-2">&amp;</span>store);
<span class="macro">assert_eq!</span>(ty.minimum(), <span class="number">1</span>);</code></pre></div>
</div></details><details class="toggle method-toggle" open><summary><section id="method.read" class="method"><a class="src rightside" href="../src/wasmtime/memory.rs.html#311-325">source</a><h4 class="code-header">pub fn <a href="#method.read" class="fn">read</a>(
    &amp;self,
    store: impl <a class="trait" href="trait.AsContext.html" title="trait wasmtime::AsContext">AsContext</a>,
    offset: <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.usize.html">usize</a>,
    buffer: &amp;mut [<a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.u8.html">u8</a>]
) -&gt; <a class="type" href="type.Result.html" title="type wasmtime::Result">Result</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.unit.html">()</a>, <a class="struct" href="struct.MemoryAccessError.html" title="struct wasmtime::MemoryAccessError">MemoryAccessError</a>&gt;</h4></section></summary><div class="docblock"><p>Safely reads memory contents at the given offset into a buffer.</p>
<p>The entire buffer will be filled.</p>
<p>If <code>offset + buffer.len()</code> exceed the current memory capacity, then the
buffer is left untouched and a <a href="struct.MemoryAccessError.html" title="struct wasmtime::MemoryAccessError"><code>MemoryAccessError</code></a> is returned.</p>
<h5 id="panics-2"><a href="#panics-2">Panics</a></h5>
<p>Panics if this memory doesn’t belong to <code>store</code>.</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.write" class="method"><a class="src rightside" href="../src/wasmtime/memory.rs.html#336-349">source</a><h4 class="code-header">pub fn <a href="#method.write" class="fn">write</a>(
    &amp;self,
    store: impl <a class="trait" href="trait.AsContextMut.html" title="trait wasmtime::AsContextMut">AsContextMut</a>,
    offset: <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.usize.html">usize</a>,
    buffer: &amp;[<a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.u8.html">u8</a>]
) -&gt; <a class="type" href="type.Result.html" title="type wasmtime::Result">Result</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.unit.html">()</a>, <a class="struct" href="struct.MemoryAccessError.html" title="struct wasmtime::MemoryAccessError">MemoryAccessError</a>&gt;</h4></section></summary><div class="docblock"><p>Safely writes contents of a buffer to this memory at the given offset.</p>
<p>If the <code>offset + buffer.len()</code> exceeds the current memory capacity, then
none of the buffer is written to memory and a <a href="struct.MemoryAccessError.html" title="struct wasmtime::MemoryAccessError"><code>MemoryAccessError</code></a> is
returned.</p>
<h5 id="panics-3"><a href="#panics-3">Panics</a></h5>
<p>Panics if this memory doesn’t belong to <code>store</code>.</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.data" class="method"><a class="src rightside" href="../src/wasmtime/memory.rs.html#359-366">source</a><h4 class="code-header">pub fn <a href="#method.data" class="fn">data</a>&lt;'a, T: 'a&gt;(&amp;self, store: impl <a class="trait" href="https://doc.rust-lang.org/nightly/core/convert/trait.Into.html" title="trait core::convert::Into">Into</a>&lt;<a class="struct" href="struct.StoreContext.html" title="struct wasmtime::StoreContext">StoreContext</a>&lt;'a, T&gt;&gt;) -&gt; &amp;'a [<a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.u8.html">u8</a>] <a href="#" class="tooltip" data-notable-ty="&amp;&#39;a [u8]">ⓘ</a></h4></section></summary><div class="docblock"><p>Returns this memory as a native Rust slice.</p>
<p>Note that this method will consider the entire store context provided as
borrowed for the duration of the lifetime of the returned slice.</p>
<h5 id="panics-4"><a href="#panics-4">Panics</a></h5>
<p>Panics if this memory doesn’t belong to <code>store</code>.</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.data_mut" class="method"><a class="src rightside" href="../src/wasmtime/memory.rs.html#376-383">source</a><h4 class="code-header">pub fn <a href="#method.data_mut" class="fn">data_mut</a>&lt;'a, T: 'a&gt;(
    &amp;self,
    store: impl <a class="trait" href="https://doc.rust-lang.org/nightly/core/convert/trait.Into.html" title="trait core::convert::Into">Into</a>&lt;<a class="struct" href="struct.StoreContextMut.html" title="struct wasmtime::StoreContextMut">StoreContextMut</a>&lt;'a, T&gt;&gt;
) -&gt; &amp;'a mut [<a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.u8.html">u8</a>] <a href="#" class="tooltip" data-notable-ty="&amp;&#39;a mut [u8]">ⓘ</a></h4></section></summary><div class="docblock"><p>Returns this memory as a native Rust mutable slice.</p>
<p>Note that this method will consider the entire store context provided as
borrowed for the duration of the lifetime of the returned slice.</p>
<h5 id="panics-5"><a href="#panics-5">Panics</a></h5>
<p>Panics if this memory doesn’t belong to <code>store</code>.</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.data_and_store_mut" class="method"><a class="src rightside" href="../src/wasmtime/memory.rs.html#397-416">source</a><h4 class="code-header">pub fn <a href="#method.data_and_store_mut" class="fn">data_and_store_mut</a>&lt;'a, T: 'a&gt;(
    &amp;self,
    store: impl <a class="trait" href="https://doc.rust-lang.org/nightly/core/convert/trait.Into.html" title="trait core::convert::Into">Into</a>&lt;<a class="struct" href="struct.StoreContextMut.html" title="struct wasmtime::StoreContextMut">StoreContextMut</a>&lt;'a, T&gt;&gt;
) -&gt; (&amp;'a mut [<a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.u8.html">u8</a>], <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.reference.html">&amp;'a mut T</a>)</h4></section></summary><div class="docblock"><p>Same as <a href="struct.Memory.html#method.data_mut" title="method wasmtime::Memory::data_mut"><code>Memory::data_mut</code></a>, but also returns the <code>T</code> from the
<a href="struct.StoreContextMut.html" title="struct wasmtime::StoreContextMut"><code>StoreContextMut</code></a>.</p>
<p>This method can be used when you want to simultaneously work with the
<code>T</code> in the store as well as the memory behind this <a href="struct.Memory.html" title="struct wasmtime::Memory"><code>Memory</code></a>. Using
<a href="struct.Memory.html#method.data_mut" title="method wasmtime::Memory::data_mut"><code>Memory::data_mut</code></a> would consider the entire store borrowed, whereas
this method allows the Rust compiler to see that the borrow of this
memory and the borrow of <code>T</code> are disjoint.</p>
<h5 id="panics-6"><a href="#panics-6">Panics</a></h5>
<p>Panics if this memory doesn’t belong to <code>store</code>.</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.data_ptr" class="method"><a class="src rightside" href="../src/wasmtime/memory.rs.html#427-429">source</a><h4 class="code-header">pub fn <a href="#method.data_ptr" class="fn">data_ptr</a>(&amp;self, store: impl <a class="trait" href="trait.AsContext.html" title="trait wasmtime::AsContext">AsContext</a>) -&gt; <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.pointer.html">*mut </a><a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.u8.html">u8</a></h4></section></summary><div class="docblock"><p>Returns the base pointer, in the host’s address space, that the memory
is located at.</p>
<p>For more information and examples see the documentation on the
<a href="struct.Memory.html" title="struct wasmtime::Memory"><code>Memory</code></a> type.</p>
<h5 id="panics-7"><a href="#panics-7">Panics</a></h5>
<p>Panics if this memory doesn’t belong to <code>store</code>.</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.data_size" class="method"><a class="src rightside" href="../src/wasmtime/memory.rs.html#441-443">source</a><h4 class="code-header">pub fn <a href="#method.data_size" class="fn">data_size</a>(&amp;self, store: impl <a class="trait" href="trait.AsContext.html" title="trait wasmtime::AsContext">AsContext</a>) -&gt; <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.usize.html">usize</a></h4></section></summary><div class="docblock"><p>Returns the byte length of this memory.</p>
<p>The returned value will be a multiple of the wasm page size, 64k.</p>
<p>For more information and examples see the documentation on the
<a href="struct.Memory.html" title="struct wasmtime::Memory"><code>Memory</code></a> type.</p>
<h5 id="panics-8"><a href="#panics-8">Panics</a></h5>
<p>Panics if this memory doesn’t belong to <code>store</code>.</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.size" class="method"><a class="src rightside" href="../src/wasmtime/memory.rs.html#454-456">source</a><h4 class="code-header">pub fn <a href="#method.size" class="fn">size</a>(&amp;self, store: impl <a class="trait" href="trait.AsContext.html" title="trait wasmtime::AsContext">AsContext</a>) -&gt; <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.u64.html">u64</a></h4></section></summary><div class="docblock"><p>Returns the size, in WebAssembly pages, of this wasm memory.</p>
<h5 id="panics-9"><a href="#panics-9">Panics</a></h5>
<p>Panics if this memory doesn’t belong to <code>store</code>.</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.grow" class="method"><a class="src rightside" href="../src/wasmtime/memory.rs.html#508-521">source</a><h4 class="code-header">pub fn <a href="#method.grow" class="fn">grow</a>(&amp;self, store: impl <a class="trait" href="trait.AsContextMut.html" title="trait wasmtime::AsContextMut">AsContextMut</a>, delta: <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.u64.html">u64</a>) -&gt; <a class="type" href="type.Result.html" title="type wasmtime::Result">Result</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.u64.html">u64</a>&gt;</h4></section></summary><div class="docblock"><p>Grows this WebAssembly memory by <code>delta</code> pages.</p>
<p>This will attempt to add <code>delta</code> more pages of memory on to the end of
this <code>Memory</code> instance. If successful this may relocate the memory and
cause <a href="struct.Memory.html#method.data_ptr" title="method wasmtime::Memory::data_ptr"><code>Memory::data_ptr</code></a> to return a new value. Additionally any
unsafely constructed slices into this memory may no longer be valid.</p>
<p>On success returns the number of pages this memory previously had
before the growth succeeded.</p>
<h5 id="errors"><a href="#errors">Errors</a></h5>
<p>Returns an error if memory could not be grown, for example if it exceeds
the maximum limits of this memory. A
<a href="trait.ResourceLimiter.html" title="trait wasmtime::ResourceLimiter"><code>ResourceLimiter</code></a> is another example of
preventing a memory to grow.</p>
<h5 id="panics-10"><a href="#panics-10">Panics</a></h5>
<p>Panics if this memory doesn’t belong to <code>store</code>.</p>
<p>This function will panic if the <a href="struct.Store.html" title="struct wasmtime::Store"><code>Store</code></a> has a
<a href="%60crate::ResourceLimiterAsync%60"><code>ResourceLimiterAsync</code></a> (see also:
<a href="%60crate::Store::limiter_async%60"><code>Store::limiter_async</code></a>. When using an
async resource limiter, use [<code>Memory::grow_async</code>] instead.</p>
<h5 id="examples-2"><a href="#examples-2">Examples</a></h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let </span>engine = Engine::default();
<span class="kw">let </span><span class="kw-2">mut </span>store = Store::new(<span class="kw-2">&amp;</span>engine, ());
<span class="kw">let </span>module = Module::new(<span class="kw-2">&amp;</span>engine, <span class="string">"(module (memory (export \"mem\") 1 2))"</span>)<span class="question-mark">?</span>;
<span class="kw">let </span>instance = Instance::new(<span class="kw-2">&amp;mut </span>store, <span class="kw-2">&amp;</span>module, <span class="kw-2">&amp;</span>[])<span class="question-mark">?</span>;
<span class="kw">let </span>memory = instance.get_memory(<span class="kw-2">&amp;mut </span>store, <span class="string">"mem"</span>).unwrap();

<span class="macro">assert_eq!</span>(memory.size(<span class="kw-2">&amp;</span>store), <span class="number">1</span>);
<span class="macro">assert_eq!</span>(memory.grow(<span class="kw-2">&amp;mut </span>store, <span class="number">1</span>)<span class="question-mark">?</span>, <span class="number">1</span>);
<span class="macro">assert_eq!</span>(memory.size(<span class="kw-2">&amp;</span>store), <span class="number">2</span>);
<span class="macro">assert!</span>(memory.grow(<span class="kw-2">&amp;mut </span>store, <span class="number">1</span>).is_err());
<span class="macro">assert_eq!</span>(memory.size(<span class="kw-2">&amp;</span>store), <span class="number">2</span>);
<span class="macro">assert_eq!</span>(memory.grow(<span class="kw-2">&amp;mut </span>store, <span class="number">0</span>)<span class="question-mark">?</span>, <span class="number">2</span>);</code></pre></div>
</div></details></div></details></div><h2 id="trait-implementations" class="section-header">Trait Implementations<a href="#trait-implementations" class="anchor">§</a></h2><div id="trait-implementations-list"><details class="toggle implementors-toggle" open><summary><section id="impl-Clone-for-Memory" class="impl"><a class="src rightside" href="../src/wasmtime/memory.rs.html#203">source</a><a href="#impl-Clone-for-Memory" class="anchor">§</a><h3 class="code-header">impl <a class="trait" href="https://doc.rust-lang.org/nightly/core/clone/trait.Clone.html" title="trait core::clone::Clone">Clone</a> for <a class="struct" href="struct.Memory.html" title="struct wasmtime::Memory">Memory</a></h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.clone" class="method trait-impl"><a class="src rightside" href="../src/wasmtime/memory.rs.html#203">source</a><a href="#method.clone" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/nightly/core/clone/trait.Clone.html#tymethod.clone" class="fn">clone</a>(&amp;self) -&gt; <a class="struct" href="struct.Memory.html" title="struct wasmtime::Memory">Memory</a></h4></section></summary><div class='docblock'>Returns a copy of the value. <a href="https://doc.rust-lang.org/nightly/core/clone/trait.Clone.html#tymethod.clone">Read more</a></div></details><details class="toggle method-toggle" open><summary><section id="method.clone_from" class="method trait-impl"><span class="rightside"><span class="since" title="Stable since Rust version 1.0.0">1.0.0</span> · <a class="src" href="https://doc.rust-lang.org/nightly/src/core/clone.rs.html#169">source</a></span><a href="#method.clone_from" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/nightly/core/clone/trait.Clone.html#method.clone_from" class="fn">clone_from</a>(&amp;mut self, source: <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.reference.html">&amp;Self</a>)</h4></section></summary><div class='docblock'>Performs copy-assignment from <code>source</code>. <a href="https://doc.rust-lang.org/nightly/core/clone/trait.Clone.html#method.clone_from">Read more</a></div></details></div></details><details class="toggle implementors-toggle" open><summary><section id="impl-Debug-for-Memory" class="impl"><a class="src rightside" href="../src/wasmtime/memory.rs.html#203">source</a><a href="#impl-Debug-for-Memory" class="anchor">§</a><h3 class="code-header">impl <a class="trait" href="https://doc.rust-lang.org/nightly/core/fmt/trait.Debug.html" title="trait core::fmt::Debug">Debug</a> for <a class="struct" href="struct.Memory.html" title="struct wasmtime::Memory">Memory</a></h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.fmt" class="method trait-impl"><a class="src rightside" href="../src/wasmtime/memory.rs.html#203">source</a><a href="#method.fmt" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/nightly/core/fmt/trait.Debug.html#tymethod.fmt" class="fn">fmt</a>(&amp;self, f: &amp;mut <a class="struct" href="https://doc.rust-lang.org/nightly/core/fmt/struct.Formatter.html" title="struct core::fmt::Formatter">Formatter</a>&lt;'_&gt;) -&gt; <a class="type" href="https://doc.rust-lang.org/nightly/core/fmt/type.Result.html" title="type core::fmt::Result">Result</a></h4></section></summary><div class='docblock'>Formats the value using the given formatter. <a href="https://doc.rust-lang.org/nightly/core/fmt/trait.Debug.html#tymethod.fmt">Read more</a></div></details></div></details><details class="toggle implementors-toggle" open><summary><section id="impl-From%3CMemory%3E-for-Extern" class="impl"><a class="src rightside" href="../src/wasmtime/externals.rs.html#155-159">source</a><a href="#impl-From%3CMemory%3E-for-Extern" class="anchor">§</a><h3 class="code-header">impl <a class="trait" href="https://doc.rust-lang.org/nightly/core/convert/trait.From.html" title="trait core::convert::From">From</a>&lt;<a class="struct" href="struct.Memory.html" title="struct wasmtime::Memory">Memory</a>&gt; for <a class="enum" href="enum.Extern.html" title="enum wasmtime::Extern">Extern</a></h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.from" class="method trait-impl"><a class="src rightside" href="../src/wasmtime/externals.rs.html#156-158">source</a><a href="#method.from" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/nightly/core/convert/trait.From.html#tymethod.from" class="fn">from</a>(r: <a class="struct" href="struct.Memory.html" title="struct wasmtime::Memory">Memory</a>) -&gt; Self</h4></section></summary><div class='docblock'>Converts to this type from the input type.</div></details></div></details><section id="impl-Copy-for-Memory" class="impl"><a class="src rightside" href="../src/wasmtime/memory.rs.html#203">source</a><a href="#impl-Copy-for-Memory" class="anchor">§</a><h3 class="code-header">impl <a class="trait" href="https://doc.rust-lang.org/nightly/core/marker/trait.Copy.html" title="trait core::marker::Copy">Copy</a> for <a class="struct" href="struct.Memory.html" title="struct wasmtime::Memory">Memory</a></h3></section></div><h2 id="synthetic-implementations" class="section-header">Auto Trait Implementations<a href="#synthetic-implementations" class="anchor">§</a></h2><div id="synthetic-implementations-list"><section id="impl-RefUnwindSafe-for-Memory" class="impl"><a href="#impl-RefUnwindSafe-for-Memory" class="anchor">§</a><h3 class="code-header">impl <a class="trait" href="https://doc.rust-lang.org/nightly/core/panic/unwind_safe/trait.RefUnwindSafe.html" title="trait core::panic::unwind_safe::RefUnwindSafe">RefUnwindSafe</a> for <a class="struct" href="struct.Memory.html" title="struct wasmtime::Memory">Memory</a></h3></section><section id="impl-Send-for-Memory" class="impl"><a href="#impl-Send-for-Memory" class="anchor">§</a><h3 class="code-header">impl <a class="trait" href="https://doc.rust-lang.org/nightly/core/marker/trait.Send.html" title="trait core::marker::Send">Send</a> for <a class="struct" href="struct.Memory.html" title="struct wasmtime::Memory">Memory</a></h3></section><section id="impl-Sync-for-Memory" class="impl"><a href="#impl-Sync-for-Memory" class="anchor">§</a><h3 class="code-header">impl <a class="trait" href="https://doc.rust-lang.org/nightly/core/marker/trait.Sync.html" title="trait core::marker::Sync">Sync</a> for <a class="struct" href="struct.Memory.html" title="struct wasmtime::Memory">Memory</a></h3></section><section id="impl-Unpin-for-Memory" class="impl"><a href="#impl-Unpin-for-Memory" class="anchor">§</a><h3 class="code-header">impl <a class="trait" href="https://doc.rust-lang.org/nightly/core/marker/trait.Unpin.html" title="trait core::marker::Unpin">Unpin</a> for <a class="struct" href="struct.Memory.html" title="struct wasmtime::Memory">Memory</a></h3></section><section id="impl-UnwindSafe-for-Memory" class="impl"><a href="#impl-UnwindSafe-for-Memory" class="anchor">§</a><h3 class="code-header">impl <a class="trait" href="https://doc.rust-lang.org/nightly/core/panic/unwind_safe/trait.UnwindSafe.html" title="trait core::panic::unwind_safe::UnwindSafe">UnwindSafe</a> for <a class="struct" href="struct.Memory.html" title="struct wasmtime::Memory">Memory</a></h3></section></div><h2 id="blanket-implementations" class="section-header">Blanket Implementations<a href="#blanket-implementations" class="anchor">§</a></h2><div id="blanket-implementations-list"><details class="toggle implementors-toggle"><summary><section id="impl-Any-for-T" class="impl"><a class="src rightside" href="https://doc.rust-lang.org/nightly/src/core/any.rs.html#140">source</a><a href="#impl-Any-for-T" class="anchor">§</a><h3 class="code-header">impl&lt;T&gt; <a class="trait" href="https://doc.rust-lang.org/nightly/core/any/trait.Any.html" title="trait core::any::Any">Any</a> for T<div class="where">where
    T: 'static + ?<a class="trait" href="https://doc.rust-lang.org/nightly/core/marker/trait.Sized.html" title="trait core::marker::Sized">Sized</a>,</div></h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.type_id" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/nightly/src/core/any.rs.html#141">source</a><a href="#method.type_id" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/nightly/core/any/trait.Any.html#tymethod.type_id" class="fn">type_id</a>(&amp;self) -&gt; <a class="struct" href="https://doc.rust-lang.org/nightly/core/any/struct.TypeId.html" title="struct core::any::TypeId">TypeId</a></h4></section></summary><div class='docblock'>Gets the <code>TypeId</code> of <code>self</code>. <a href="https://doc.rust-lang.org/nightly/core/any/trait.Any.html#tymethod.type_id">Read more</a></div></details></div></details><details class="toggle implementors-toggle"><summary><section id="impl-Borrow%3CT%3E-for-T" class="impl"><a class="src rightside" href="https://doc.rust-lang.org/nightly/src/core/borrow.rs.html#208">source</a><a href="#impl-Borrow%3CT%3E-for-T" class="anchor">§</a><h3 class="code-header">impl&lt;T&gt; <a class="trait" href="https://doc.rust-lang.org/nightly/core/borrow/trait.Borrow.html" title="trait core::borrow::Borrow">Borrow</a>&lt;T&gt; for T<div class="where">where
    T: ?<a class="trait" href="https://doc.rust-lang.org/nightly/core/marker/trait.Sized.html" title="trait core::marker::Sized">Sized</a>,</div></h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.borrow" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/nightly/src/core/borrow.rs.html#210">source</a><a href="#method.borrow" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/nightly/core/borrow/trait.Borrow.html#tymethod.borrow" class="fn">borrow</a>(&amp;self) -&gt; <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.reference.html">&amp;T</a></h4></section></summary><div class='docblock'>Immutably borrows from an owned value. <a href="https://doc.rust-lang.org/nightly/core/borrow/trait.Borrow.html#tymethod.borrow">Read more</a></div></details></div></details><details class="toggle implementors-toggle"><summary><section id="impl-BorrowMut%3CT%3E-for-T" class="impl"><a class="src rightside" href="https://doc.rust-lang.org/nightly/src/core/borrow.rs.html#216">source</a><a href="#impl-BorrowMut%3CT%3E-for-T" class="anchor">§</a><h3 class="code-header">impl&lt;T&gt; <a class="trait" href="https://doc.rust-lang.org/nightly/core/borrow/trait.BorrowMut.html" title="trait core::borrow::BorrowMut">BorrowMut</a>&lt;T&gt; for T<div class="where">where
    T: ?<a class="trait" href="https://doc.rust-lang.org/nightly/core/marker/trait.Sized.html" title="trait core::marker::Sized">Sized</a>,</div></h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.borrow_mut" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/nightly/src/core/borrow.rs.html#217">source</a><a href="#method.borrow_mut" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/nightly/core/borrow/trait.BorrowMut.html#tymethod.borrow_mut" class="fn">borrow_mut</a>(&amp;mut self) -&gt; <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.reference.html">&amp;mut T</a></h4></section></summary><div class='docblock'>Mutably borrows from an owned value. <a href="https://doc.rust-lang.org/nightly/core/borrow/trait.BorrowMut.html#tymethod.borrow_mut">Read more</a></div></details></div></details><details class="toggle implementors-toggle"><summary><section id="impl-From%3CT%3E-for-T" class="impl"><a class="src rightside" href="https://doc.rust-lang.org/nightly/src/core/convert/mod.rs.html#763">source</a><a href="#impl-From%3CT%3E-for-T" class="anchor">§</a><h3 class="code-header">impl&lt;T&gt; <a class="trait" href="https://doc.rust-lang.org/nightly/core/convert/trait.From.html" title="trait core::convert::From">From</a>&lt;T&gt; for T</h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.from-1" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/nightly/src/core/convert/mod.rs.html#766">source</a><a href="#method.from-1" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/nightly/core/convert/trait.From.html#tymethod.from" class="fn">from</a>(t: T) -&gt; T</h4></section></summary><div class="docblock"><p>Returns the argument unchanged.</p>
</div></details></div></details><details class="toggle implementors-toggle"><summary><section id="impl-Into%3CU%3E-for-T" class="impl"><a class="src rightside" href="https://doc.rust-lang.org/nightly/src/core/convert/mod.rs.html#747-749">source</a><a href="#impl-Into%3CU%3E-for-T" class="anchor">§</a><h3 class="code-header">impl&lt;T, U&gt; <a class="trait" href="https://doc.rust-lang.org/nightly/core/convert/trait.Into.html" title="trait core::convert::Into">Into</a>&lt;U&gt; for T<div class="where">where
    U: <a class="trait" href="https://doc.rust-lang.org/nightly/core/convert/trait.From.html" title="trait core::convert::From">From</a>&lt;T&gt;,</div></h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.into" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/nightly/src/core/convert/mod.rs.html#756">source</a><a href="#method.into" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/nightly/core/convert/trait.Into.html#tymethod.into" class="fn">into</a>(self) -&gt; U</h4></section></summary><div class="docblock"><p>Calls <code>U::from(self)</code>.</p>
<p>That is, this conversion is whatever the implementation of
<code><a href="https://doc.rust-lang.org/nightly/core/convert/trait.From.html" title="trait core::convert::From">From</a>&lt;T&gt; for U</code> chooses to do.</p>
</div></details></div></details><details class="toggle implementors-toggle"><summary><section id="impl-ToOwned-for-T" class="impl"><a class="src rightside" href="https://doc.rust-lang.org/nightly/src/alloc/borrow.rs.html#83-85">source</a><a href="#impl-ToOwned-for-T" class="anchor">§</a><h3 class="code-header">impl&lt;T&gt; <a class="trait" href="https://doc.rust-lang.org/nightly/alloc/borrow/trait.ToOwned.html" title="trait alloc::borrow::ToOwned">ToOwned</a> for T<div class="where">where
    T: <a class="trait" href="https://doc.rust-lang.org/nightly/core/clone/trait.Clone.html" title="trait core::clone::Clone">Clone</a>,</div></h3></section></summary><div class="impl-items"><details class="toggle" open><summary><section id="associatedtype.Owned" class="associatedtype trait-impl"><a href="#associatedtype.Owned" class="anchor">§</a><h4 class="code-header">type <a href="https://doc.rust-lang.org/nightly/alloc/borrow/trait.ToOwned.html#associatedtype.Owned" class="associatedtype">Owned</a> = T</h4></section></summary><div class='docblock'>The resulting type after obtaining ownership.</div></details><details class="toggle method-toggle" open><summary><section id="method.to_owned" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/nightly/src/alloc/borrow.rs.html#88">source</a><a href="#method.to_owned" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/nightly/alloc/borrow/trait.ToOwned.html#tymethod.to_owned" class="fn">to_owned</a>(&amp;self) -&gt; T</h4></section></summary><div class='docblock'>Creates owned data from borrowed data, usually by cloning. <a href="https://doc.rust-lang.org/nightly/alloc/borrow/trait.ToOwned.html#tymethod.to_owned">Read more</a></div></details><details class="toggle method-toggle" open><summary><section id="method.clone_into" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/nightly/src/alloc/borrow.rs.html#92">source</a><a href="#method.clone_into" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/nightly/alloc/borrow/trait.ToOwned.html#method.clone_into" class="fn">clone_into</a>(&amp;self, target: <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.reference.html">&amp;mut T</a>)</h4></section></summary><div class='docblock'>Uses borrowed data to replace owned data, usually by cloning. <a href="https://doc.rust-lang.org/nightly/alloc/borrow/trait.ToOwned.html#method.clone_into">Read more</a></div></details></div></details><details class="toggle implementors-toggle"><summary><section id="impl-TryFrom%3CU%3E-for-T" class="impl"><a class="src rightside" href="https://doc.rust-lang.org/nightly/src/core/convert/mod.rs.html#803-805">source</a><a href="#impl-TryFrom%3CU%3E-for-T" class="anchor">§</a><h3 class="code-header">impl&lt;T, U&gt; <a class="trait" href="https://doc.rust-lang.org/nightly/core/convert/trait.TryFrom.html" title="trait core::convert::TryFrom">TryFrom</a>&lt;U&gt; for T<div class="where">where
    U: <a class="trait" href="https://doc.rust-lang.org/nightly/core/convert/trait.Into.html" title="trait core::convert::Into">Into</a>&lt;T&gt;,</div></h3></section></summary><div class="impl-items"><details class="toggle" open><summary><section id="associatedtype.Error" class="associatedtype trait-impl"><a href="#associatedtype.Error" class="anchor">§</a><h4 class="code-header">type <a href="https://doc.rust-lang.org/nightly/core/convert/trait.TryFrom.html#associatedtype.Error" class="associatedtype">Error</a> = <a class="enum" href="https://doc.rust-lang.org/nightly/core/convert/enum.Infallible.html" title="enum core::convert::Infallible">Infallible</a></h4></section></summary><div class='docblock'>The type returned in the event of a conversion error.</div></details><details class="toggle method-toggle" open><summary><section id="method.try_from" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/nightly/src/core/convert/mod.rs.html#810">source</a><a href="#method.try_from" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/nightly/core/convert/trait.TryFrom.html#tymethod.try_from" class="fn">try_from</a>(value: U) -&gt; <a class="enum" href="https://doc.rust-lang.org/nightly/core/result/enum.Result.html" title="enum core::result::Result">Result</a>&lt;T, &lt;T as <a class="trait" href="https://doc.rust-lang.org/nightly/core/convert/trait.TryFrom.html" title="trait core::convert::TryFrom">TryFrom</a>&lt;U&gt;&gt;::<a class="associatedtype" href="https://doc.rust-lang.org/nightly/core/convert/trait.TryFrom.html#associatedtype.Error" title="type core::convert::TryFrom::Error">Error</a>&gt;</h4></section></summary><div class='docblock'>Performs the conversion.</div></details></div></details><details class="toggle implementors-toggle"><summary><section id="impl-TryInto%3CU%3E-for-T" class="impl"><a class="src rightside" href="https://doc.rust-lang.org/nightly/src/core/convert/mod.rs.html#788-790">source</a><a href="#impl-TryInto%3CU%3E-for-T" class="anchor">§</a><h3 class="code-header">impl&lt;T, U&gt; <a class="trait" href="https://doc.rust-lang.org/nightly/core/convert/trait.TryInto.html" title="trait core::convert::TryInto">TryInto</a>&lt;U&gt; for T<div class="where">where
    U: <a class="trait" href="https://doc.rust-lang.org/nightly/core/convert/trait.TryFrom.html" title="trait core::convert::TryFrom">TryFrom</a>&lt;T&gt;,</div></h3></section></summary><div class="impl-items"><details class="toggle" open><summary><section id="associatedtype.Error-1" class="associatedtype trait-impl"><a href="#associatedtype.Error-1" class="anchor">§</a><h4 class="code-header">type <a href="https://doc.rust-lang.org/nightly/core/convert/trait.TryInto.html#associatedtype.Error" class="associatedtype">Error</a> = &lt;U as <a class="trait" href="https://doc.rust-lang.org/nightly/core/convert/trait.TryFrom.html" title="trait core::convert::TryFrom">TryFrom</a>&lt;T&gt;&gt;::<a class="associatedtype" href="https://doc.rust-lang.org/nightly/core/convert/trait.TryFrom.html#associatedtype.Error" title="type core::convert::TryFrom::Error">Error</a></h4></section></summary><div class='docblock'>The type returned in the event of a conversion error.</div></details><details class="toggle method-toggle" open><summary><section id="method.try_into" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/nightly/src/core/convert/mod.rs.html#795">source</a><a href="#method.try_into" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/nightly/core/convert/trait.TryInto.html#tymethod.try_into" class="fn">try_into</a>(self) -&gt; <a class="enum" href="https://doc.rust-lang.org/nightly/core/result/enum.Result.html" title="enum core::result::Result">Result</a>&lt;U, &lt;U as <a class="trait" href="https://doc.rust-lang.org/nightly/core/convert/trait.TryFrom.html" title="trait core::convert::TryFrom">TryFrom</a>&lt;T&gt;&gt;::<a class="associatedtype" href="https://doc.rust-lang.org/nightly/core/convert/trait.TryFrom.html#associatedtype.Error" title="type core::convert::TryFrom::Error">Error</a>&gt;</h4></section></summary><div class='docblock'>Performs the conversion.</div></details></div></details></div><script type="text/json" id="notable-traits-data">{"&'a [u8]":"<h3>Notable traits for <code>&amp;[<a class=\"primitive\" href=\"https://doc.rust-lang.org/nightly/std/primitive.u8.html\">u8</a>]</code></h3><pre><code><div class=\"where\">impl <a class=\"trait\" href=\"https://doc.rust-lang.org/nightly/std/io/trait.Read.html\" title=\"trait std::io::Read\">Read</a> for &amp;[<a class=\"primitive\" href=\"https://doc.rust-lang.org/nightly/std/primitive.u8.html\">u8</a>]</div>","&'a mut [u8]":"<h3>Notable traits for <code>&amp;mut [<a class=\"primitive\" href=\"https://doc.rust-lang.org/nightly/std/primitive.u8.html\">u8</a>]</code></h3><pre><code><div class=\"where\">impl <a class=\"trait\" href=\"https://doc.rust-lang.org/nightly/std/io/trait.Write.html\" title=\"trait std::io::Write\">Write</a> for &amp;mut [<a class=\"primitive\" href=\"https://doc.rust-lang.org/nightly/std/primitive.u8.html\">u8</a>]</div>"}</script></section></div></main></body></html>